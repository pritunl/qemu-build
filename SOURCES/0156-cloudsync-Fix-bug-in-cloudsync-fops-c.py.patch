From d8c98e9785e652692d928a2efbbb571703f728b0 Mon Sep 17 00:00:00 2001
From: Anuradha Talur <atalur@commvault.com>
Date: Wed, 24 Apr 2019 12:35:08 -0700
Subject: [PATCH 156/169] cloudsync: Fix bug in cloudsync-fops-c.py

In some of the fops generated by generator.py, xdata request
was not being wound to the child xlator correctly.

This was happening because when though the logic in
cloudsync-fops-c.py was correct, generator.py was generating
a resultant code that omits this logic.

Made changes in cloudsync-fops-c.py so that correct code is
produced.

backport of: https://review.gluster.org/#/c/glusterfs/+/22617/

> Change-Id: I6f25bdb36ede06fd03be32c04087a75639d79150
> updates: bz#1642168
> Signed-off-by: Anuradha Talur <atalur@commvault.com>

Change-Id: I87cc71e98c2c6cec78a6e84850fc8d82f8dd4dfd
Signed-off-by: Susant Palai <spalai@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/172195
Tested-by: RHGS Build Bot <nigelb@redhat.com>
Reviewed-by: Atin Mukherjee <amukherj@redhat.com>
---
 xlators/features/cloudsync/src/cloudsync-fops-c.py | 24 +++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)

diff --git a/xlators/features/cloudsync/src/cloudsync-fops-c.py b/xlators/features/cloudsync/src/cloudsync-fops-c.py
index 8878b70..c444ea6 100755
--- a/xlators/features/cloudsync/src/cloudsync-fops-c.py
+++ b/xlators/features/cloudsync/src/cloudsync-fops-c.py
@@ -39,7 +39,15 @@ cs_@NAME@ (call_frame_t *frame, xlator_t *this,
         else
                 state = GF_CS_LOCAL;
 
-        local->xattr_req = xdata ? dict_ref (xdata) : (xdata = dict_new ());
+        xdata = xdata ? dict_ref (xdata) : dict_new ();
+
+        if (!xdata) {
+                gf_msg (this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
+                op_errno = ENOMEM;
+                goto err;
+        }
+
+        local->xattr_req = xdata;
 
         ret = dict_set_uint32 (local->xattr_req, GF_CS_OBJECT_STATUS, 1);
         if (ret) {
@@ -187,19 +195,29 @@ int32_t
 cs_@NAME@ (call_frame_t *frame, xlator_t *this,
            @LONG_ARGS@)
 {
+        int              op_errno = EINVAL;
         cs_local_t      *local = NULL;
         int              ret   = 0;
 
         local = cs_local_init (this, frame, loc, NULL, GF_FOP_@UPNAME@);
         if (!local) {
                 gf_msg (this->name, GF_LOG_ERROR, 0, 0, "local is NULL");
+                op_errno = ENOMEM;
                 goto err;
         }
 
         if (loc->inode->ia_type == IA_IFDIR)
                 goto wind;
 
-        local->xattr_req = xdata ? dict_ref (xdata) : dict_new ();
+        xdata = xdata ? dict_ref (xdata) : dict_new ();
+
+        if (!xdata) {
+                gf_msg (this->name, GF_LOG_ERROR, 0, 0, "insufficient memory");
+                op_errno = ENOMEM;
+                goto err;
+        }
+
+        local->xattr_req = xdata;
 
         ret = dict_set_uint32 (local->xattr_req, GF_CS_OBJECT_STATUS, 1);
         if (ret) {
@@ -215,7 +233,7 @@ wind:
 
         return 0;
 err:
-        CS_STACK_UNWIND (@NAME@, frame, -1, errno, @CBK_ERROR_ARGS@);
+        CS_STACK_UNWIND (@NAME@, frame, -1, op_errno, @CBK_ERROR_ARGS@);
 
         return 0;
 }
-- 
1.8.3.1

